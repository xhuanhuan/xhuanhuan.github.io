<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Xhuanhuan&#39;s Blog</title>
    <link rel="Shortcut Icon" href="icon.jpg">
    <link rel="stylesheet" href="/css/bootstrap.min.css">
      <link rel="stylesheet" href="/css/style.css">
        <link rel="stylesheet" href="/css/font-awesome.min.css">
        <link rel="stylesheet" href="/css/fontdiao.css">
    </head>
<body>
    <div class="main">
        
    <article>
      <header>
  <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#my-navbar">
            <span class="sr-only">切换导航</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>

        <ul class="nav nav-pills navbar-left" role="tablist">
        <li><div class="navbar-left" style="margin-top:2px;width:45px;height:45px;border-radius:100%;">
          <img id="head1" class="img-responsive img-circle" src="/images/head1.JPG">
        </div></li>
        <li class="banner">  <a href="/">Xhuanhuan&#39;s Blog</a></li>
         </ul>
       </div>
       
       <div class="mytittle">
         JavaScript基础之面试篇（一）
       </div>
       
   <div class="navbar-collapse" id="my-navbar">

    <ul class="nav nav-pills navbar-right menu_list" role="tablist">
        
            <li class="navlist"><a href="/" >Home</a></li>
        
            <li class="navlist"><a href="/archives" >Archives</a></li>
        
            <li class="navlist"><a href="/myworks" >My-Works</a></li>
        
    </ul>
  </div>
  </nav>
</header>

      <div class="myfirstarchive">
        <img src="/images/JavaScript基础之面试篇（一）.JPG ">
      <div class="title-on-img">
        <h1 class='post-title' style="color:white;">
            <span>JavaScript基础之面试篇（一）</span>
        </h1>
      </div>
      </div>

      <div class="container">
      <div class="row">
      <div  class = 'col-xs-12 col-xs-offset-0 col-md-7 col-md-offset-1 col-sm-7 col-sm-offset-1 col-lg-7 col-lg-offset-1'>
        <div class="well">
          <div style = 'text-align:right'>
            <button type="button" class="btn btn-success" id='but2'><a href="/archives">返回</a></button>
            <hr>
          </div>
         <div class="postblock">
          <h1 class='post-title' style="border-bottom:1px solid #f0f0f0;">
              <span>JavaScript基础之面试篇（一）</span>
          </h1>
          <section class='post-content'>
              <h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h3><p>这篇博文主要是针对前端面试常见的js问题进行的总结，也算是博主在就业前夕对js的复习吧，为前端面试做准备。此外也希望可以帮到大家。<br>本文总结的问题并非博主总结，只是对原文的查漏补缺，详见<a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" target="_blank" rel="external">原文</a><br><a id="more"></a></p>
<h4 id="1-JS基本数据类型"><a href="#1-JS基本数据类型" class="headerlink" title="1.JS基本数据类型"></a>1.JS基本数据类型</h4><pre><code>js包括5种基本数据类型：Undefined,Boolean,String,Null,Number（注意还有一种引用数据类型Object）。
</code></pre><h4 id="2-JS有哪些内置对象"><a href="#2-JS有哪些内置对象" class="headerlink" title="2.JS有哪些内置对象"></a>2.JS有哪些内置对象</h4><pre><code>Object 是 JavaScript 中所有对象的父对象;
数据封装类对象：Object、Array、Boolean、Number 和 String;
其他对象：Global,Function、Arguments(可理解成由函数输入参数组成的对象)、Math、Date、RegExp（正则表达式）、Error;
</code></pre><h4 id="3-列出几条JavaScript的基本规范？"><a href="#3-列出几条JavaScript的基本规范？" class="headerlink" title="3.列出几条JavaScript的基本规范？"></a>3.列出几条JavaScript的基本规范？</h4><pre><code>1.不要在同一行声明多个变量。
2.请使用 ===/!==来比较true/false或者数值
3.使用对象字面量替代new Array这种形式
4.不要使用全局函数。
5.Switch语句必须带有default分支
6.函数不应该有时候有返回值，有时候没有返回值。
7.For循环必须使用大括号
8.If语句必须使用大括号
9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。
</code></pre><h4 id="4-JavaScript原型，原型链-有什么特点？"><a href="#4-JavaScript原型，原型链-有什么特点？" class="headerlink" title="4.JavaScript原型，原型链 ? 有什么特点？"></a>4.JavaScript原型，原型链 ? 有什么特点？</h4><h5 id="4-1原型"><a href="#4-1原型" class="headerlink" title="4.1原型"></a>4.1原型</h5><p>我们创建的每个函数都有一个prototype(原型)属性，他是一个指针，指向一个对象，这个对象包含了特定类型的所有实例所共享的属性和方法。按照字面理解，prototype就是调用构造函数创建的实例的原型对象。</p>
<pre><code>function Person(){
}
Person.prototype.name=&quot;Nicholas&quot;;
Person.prototype.age=27;
Person.prototype.job=&quot;Software Engineer&quot;;
Person.prototype.sayName=function(){
  alert(this.name);
};
var person1=new Person();
var person2=new Person();
person2.name=&quot;xiaohuan&quot;;

person1.sayName();//&quot;Nicholas&quot;
person2.sayName();//&quot;xiaohuan&quot;
delete person2.name;
person2.sayName();//&quot;Nicholas&quot;
</code></pre><h5 id="4-2原型链"><a href="#4-2原型链" class="headerlink" title="4.2原型链"></a>4.2原型链</h5><p>假如我们让原型对象等于另一个类型的实例，那么原型对象将包含指向另一个类型的指针，相应的，另一个原对象又包含了指向另一个类型的指针，以此类推。当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，他就会去 prototype里找这个属性，这个prototype又会有自己的prototype,于是就这样一直找下去，也就是我们平时所说的原型链的概念。</p>
<pre><code>function SuperType(){
  this.property=true;
}
SuperType.prototype.getSuperValue=function(){
  return this.property;
}
function SubType(){
  this.Subproperty=false;
}
SubType.prototype=new SuperType();
SubType.prototype.getSubValue=function(){
  return this.Subproperty;
}
var instance=new SubType();
alert(instance.getSuperValue());//true
</code></pre><h5 id="4-3特点"><a href="#4-3特点" class="headerlink" title="4.3特点"></a>4.3特点</h5><p> JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。<br> 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。</p>
<pre><code>function Func(){}
  Func.prototype.name = &quot;Sean&quot;;
  Func.prototype.getInfo = function() {
    return this.name;
}
var person = new Func();//现在可以参考var person = Object.create(oldObject);
console.log(person.getInfo());//&quot;Sean&quot;
console.log(Func.prototype); // { name=&quot;Sean&quot;, getInfo=function()}
</code></pre><h4 id="5-JavaScript有几种类型的值？你能画一下他们的内存图吗？"><a href="#5-JavaScript有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="5.JavaScript有几种类型的值？你能画一下他们的内存图吗？"></a>5.JavaScript有几种类型的值？你能画一下他们的内存图吗？</h4><pre><code>JavaScript包含两种数据类型值：基本类型值（Undefined、Null、String、Boolean、Number）和引用类型值（Object、Array、Function）。
两种类型的区别是：存储位置不同。基本类型值是直接存储在**栈**(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在**堆**(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。
</code></pre><p><img src="https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966" alt=""></p>
<h4 id="6-如何将字符串转化为数字，例如’12-3b’"><a href="#6-如何将字符串转化为数字，例如’12-3b’" class="headerlink" title="6.如何将字符串转化为数字，例如’12.3b’?"></a>6.如何将字符串转化为数字，例如’12.3b’?</h4><p>1.js提供了parseInt()和parseFloat()两个转换函数。前者把值转换成整数，后者把值转换成浮点数。</p>
<pre><code>parseInt(&quot;1234blue&quot;); //returns 1234
parseInt(&quot;0xA&quot;); //returns 10
parseInt(&quot;22.5&quot;); //returns 22
parseInt(&quot;blue&quot;); //returns NaN
parseInt(&quot;AF&quot;, 16); //returns 175
parseInt(&quot;10&quot;, 2); //returns 2
parseInt(&quot;10&quot;, 8); //returns 8
parseInt(&quot;10&quot;, 10); //returns 10
</code></pre><p>parseFloat()没有基模式,字符串必须以十进制形式表示浮点数</p>
<pre><code>parseFloat(&quot;1234blue&quot;); //returns 1234.0
parseFloat(&quot;0xA&quot;); //returns 0
parseFloat(&quot;22.34.5&quot;); //returns 22.34
parseFloat(&quot;blue&quot;); //returns NaN
</code></pre><p>2.正则表达式</p>
<pre><code>parseFloat(&apos;12.3b&apos;.match(/\d+\.?\d+/g)[0]);//12.3
</code></pre><h4 id="7-如何将浮点数点左边的数每三位添加一个逗号，如12000000-11转化为『12-000-000-11』"><a href="#7-如何将浮点数点左边的数每三位添加一个逗号，如12000000-11转化为『12-000-000-11』" class="headerlink" title="7.如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?"></a>7.如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?</h4><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">commafy</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> num&amp;&amp;num.toString().replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+\.)/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$<span class="number">1</span>,$<span class="number">2</span></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> $<span class="number">2</span>+<span class="string">','</span>;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> s=commafy(<span class="number">124320493.211</span>);</div><div class="line"><span class="built_in">console</span>.log(s);</div></pre></td></tr></table></figure>
</code></pre><h4 id="8-如何实现数组的随机排序？"><a href="#8-如何实现数组的随机排序？" class="headerlink" title="8.如何实现数组的随机排序？"></a>8.如何实现数组的随机排序？</h4><p>方法1：</p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort1</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=arr.length;i&lt;len;i++)&#123;</div><div class="line">    <span class="keyword">var</span> rand = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*len);</div><div class="line">    <span class="keyword">var</span> temp = arr[rand];</div><div class="line">    arr[rand] = arr[i];</div><div class="line">    arr[i] = temp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(randSort1(arr));</div></pre></td></tr></table></figure>
</code></pre><p>方法2：</p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort2</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> tempArr=[];</div><div class="line">  <span class="keyword">while</span>(arr.length&gt;<span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">var</span> index=<span class="built_in">Math</span>.random()*arr.length;</div><div class="line">    tempArr.push(arr.splice(index,<span class="number">1</span>)[<span class="number">0</span>]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> tempArr;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(randomSort2(arr));</div></pre></td></tr></table></figure>
</code></pre><p>方法3：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</div><div class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(arr);</div></pre></td></tr></table></figure></p>
<h4 id="9-Javascript如何实现继承？"><a href="#9-Javascript如何实现继承？" class="headerlink" title="9.Javascript如何实现继承？"></a>9.Javascript如何实现继承？</h4><pre><code>js继承主要包括四种：构造继承；原型继承；实例继承；拷贝继承。
</code></pre><p>9.1 构造继承法：在子类中执行父类的构造函数</p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.colors=[<span class="string">'green'</span>,<span class="string">'red'</span>,<span class="string">'blue'</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  SuperType.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> intance1=<span class="keyword">new</span> SuperType();</div><div class="line">intance1.colors.push(<span class="string">'black'</span>);</div><div class="line"><span class="built_in">console</span>.log(intance1.colors);<span class="comment">//['green','red','blue','black'];</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> intance2=<span class="keyword">new</span> SubType();</div><div class="line"><span class="built_in">console</span>.log(intance2.colors);<span class="comment">//['green','red','blue'];</span></div></pre></td></tr></table></figure>
</code></pre><p>9.2 原型继承法：将已有的对象赋给构造函数的原型</p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">  F.prototype=o;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">  <span class="attr">name</span>:<span class="string">"Nicholas"</span>,</div><div class="line">  <span class="attr">friends</span>:[<span class="string">"Shelly"</span>,<span class="string">"Court"</span>,<span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"><span class="comment">//var anotherperson=Object.create(person,&#123;name:&#123;value:"Greg"&#125;&#125;);</span></div><div class="line"><span class="keyword">var</span> anotherperson=object(person);</div><div class="line">anotherperson.name=<span class="string">"Greg"</span>;</div><div class="line">anotherperson.friends.push(<span class="string">"Rob"</span>);</div><div class="line"><span class="built_in">console</span>.log(anotherperson.name);</div><div class="line"><span class="built_in">console</span>.log(person.friends);</div><div class="line"></div><div class="line"><span class="keyword">var</span> yetanotherperson=object(person);</div><div class="line">yetanotherperson.name=<span class="string">"Linda"</span>;</div><div class="line"><span class="comment">//var yetanotherperson=Object.create(person,&#123;name:&#123;value:"Linda"&#125;&#125;);</span></div><div class="line">yetanotherperson.friends.push(<span class="string">"Barbie"</span>);</div><div class="line"><span class="built_in">console</span>.log(yetanotherperson.name);</div><div class="line"><span class="built_in">console</span>.log(person.friends);</div></pre></td></tr></table></figure>
</code></pre><p>9.3 实例继承法:构造函数返回一个实例，对象的构造函数实际上是实例的构造函数</p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dwn</span>(<span class="params">s</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(s);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyDate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> instance = <span class="keyword">new</span> <span class="built_in">Date</span>();   <span class="comment">//instance是一个新创建的日期对象</span></div><div class="line">  instance.printDate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//对日期对象instance扩展printDate()方法</span></div><div class="line">      dwn(instance.toLocaleString());</div><div class="line">  &#125;</div><div class="line">      <span class="keyword">return</span> instance;   <span class="comment">//将instance作为构造函数的返回值返回</span></div><div class="line"> &#125;</div><div class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> MyDate();</div><div class="line">dwn(date.toGMTString());</div><div class="line">date.printDate();    </div><div class="line">dwn(date <span class="keyword">instanceof</span> MyDate);  <span class="comment">//false</span></div><div class="line">dwn(date <span class="keyword">instanceof</span> <span class="built_in">Date</span>);    <span class="comment">//true</span></div><div class="line"><span class="comment">//对象的构造函数将会是实际构造的对象的构造函数（new Date()），而不是类型本身的构造函数(new MyDate())</span></div></pre></td></tr></table></figure>
</code></pre><p>9.4 拷贝继承法:通过对象属性的复制来实现继承<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">dimension</span>)</span></div><div class="line">     &#123;</div><div class="line">            <span class="keyword">this</span>.dimension = dimension;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> Point2D = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span></div><div class="line">    &#123;</div><div class="line">            <span class="keyword">this</span>.x = x;</div><div class="line">            <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line">Point2D.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">2</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> each <span class="keyword">in</span> p)   <span class="comment">//将对象的属性进行一对一的复制。</span></div><div class="line">        &#123;</div><div class="line">             <span class="comment">//this[each] = p[each];</span></div><div class="line">             <span class="keyword">this</span>.prototype[each] = p[each];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">Point2D.extend();</div><div class="line">    <span class="comment">//console.log(Point2D.dimension);</span></div><div class="line">    <span class="built_in">console</span>.log(Point2D.prototype.dimension);</div></pre></td></tr></table></figure></p>
<p>注：原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'wang'</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">28</span>;</div><div class="line">&#125;</div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();<span class="comment">//继承了Parent，通过原型</span></div><div class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> Child();</div><div class="line"><span class="built_in">console</span>.log(demo.age);</div><div class="line"><span class="built_in">console</span>.log(demo.name);<span class="comment">//得到被继承的属性</span></div></pre></td></tr></table></figure></p>
<h4 id="10-JavaScript继承的几种实现方式？"><a href="#10-JavaScript继承的几种实现方式？" class="headerlink" title="10.JavaScript继承的几种实现方式？"></a>10.JavaScript继承的几种实现方式？</h4><pre><code>接口继承（如纯虚函数）和实现继承（如非虚函数）。接口继承只继承方法签名，实现继承则继承实际的方法。ECMAScript只支持实现继承，主要依靠原型链实现。
</code></pre><h4 id="11-javascript创建对象的几种方式？"><a href="#11-javascript创建对象的几种方式？" class="headerlink" title="11.javascript创建对象的几种方式？"></a>11.javascript创建对象的几种方式？</h4><p>11.1 工厂模式：用函数来封装以特定接口创建对象的细节</p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  o.name=name;</div><div class="line">  o.age=age;</div><div class="line">  o.job=job;</div><div class="line">  o.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);&#125;;</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=createPerson(<span class="string">'xiaohuan'</span>,<span class="number">25</span>,<span class="string">'student'</span>);</div></pre></td></tr></table></figure>
</code></pre><p>工厂模式虽然解决了创建多个相似对象问题，但没有解决对象的识别问题（即怎样知道一个对象的类型）。</p>
<p>11.2 构造函数模式：优点是解决了对象识别问题；缺点是 每个方法都要在每个实例上重新创建一遍。</p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name=name;</div><div class="line">  <span class="keyword">this</span>.age=age;</div><div class="line">  <span class="keyword">this</span>.job=job;</div><div class="line">  <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">'xiaohuan'</span>,<span class="number">25</span>,<span class="string">'student'</span>);</div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></div><div class="line"><span class="comment">//将构造函数当做函数</span></div><div class="line"><span class="keyword">var</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">Person.call(o,<span class="string">'xiaobo'</span>,<span class="number">23</span>,<span class="string">'student'</span>);</div><div class="line"><span class="built_in">console</span>.log(o);<span class="comment">//&#123; name: 'xiaobo', age: 23, job: 'student', sayName: [Function] &#125;</span></div><div class="line"><span class="comment">//不同的实例的方法不同</span></div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">'xiaohuan'</span>,<span class="number">25</span>,<span class="string">'student'</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.sayName==person2.sayName);<span class="comment">//false</span></div></pre></td></tr></table></figure>
</code></pre><p>与工厂模式的不同之处在于不用显式的创建对象并返回，只需要直接将属性和方法赋给this；创建实例必须使用new操作符。</p>
<p>11.3 原型模式:优点是不同实例的方法相同，缺点是 原型属性中的引用类型。</p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">  <span class="attr">name</span>:<span class="string">"Nicholas"</span>,</div><div class="line">  <span class="attr">age</span>:<span class="number">27</span>,</div><div class="line">  <span class="attr">job</span>:<span class="string">"Software Engineer"</span>,</div><div class="line">  <span class="attr">friends</span>:[<span class="string">"Shelly"</span>,<span class="string">"Court"</span>],</div><div class="line">  <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person1.sayName==person2.sayName);<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person1.friends===person2.friends)<span class="comment">//true</span></div><div class="line"><span class="comment">//操作引用类型将导致问题</span></div><div class="line">person1.friends.push(<span class="string">"xiaohuan"</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.friends===person2.friends)<span class="comment">//true</span></div></pre></td></tr></table></figure>
</code></pre><p>11.4 组合构造函数模式与原型模式（目前最常用）:构造函数模式用于实例属性，原型模式用于定义方法属性和共享属性</p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name=name;</div><div class="line">  <span class="keyword">this</span>.age=age;</div><div class="line">  <span class="keyword">this</span>.job=job;</div><div class="line">  <span class="keyword">this</span>.friends=[<span class="string">"Shelly"</span>,<span class="string">"Court"</span>];</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">  <span class="attr">constructor</span>:Person,</div><div class="line">  <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">'xiaohuan'</span>,<span class="number">25</span>,<span class="string">'student'</span>);</div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">'xiaobo'</span>,<span class="number">23</span>,<span class="string">'student'</span>);</div><div class="line">person1.friends.push(<span class="string">"nana"</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.friends===person2.friends)<span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(person1.sayName===person2.sayName)<span class="comment">//true</span></div></pre></td></tr></table></figure>
</code></pre><p>11.5 动态原型模式:</p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name=name;</div><div class="line">  <span class="keyword">this</span>.age=age;</div><div class="line">  <span class="keyword">this</span>.job=job;</div><div class="line">  <span class="keyword">this</span>.friends=[<span class="string">"Shelly"</span>,<span class="string">"Court"</span>];</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.sayName!==<span class="string">"function"</span>)&#123;</div><div class="line">    Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);&#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>11.6 寄生构造函数模式:与工厂模式类似，区别在于采用new操作符。</p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  o.name=name;</div><div class="line">  o.age=age;</div><div class="line">  o.job=job;</div><div class="line">  o.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);&#125;;</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">'xiaohuan'</span>,<span class="number">25</span>,<span class="string">'student'</span>);</div></pre></td></tr></table></figure>
</code></pre><p>11.7 稳妥构造函数模式：同工厂模式？？</p>
<p>11.8 对象字面量的方式：</p>
<pre><code>person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;};
</code></pre><h4 id="12-Javascript作用链域"><a href="#12-Javascript作用链域" class="headerlink" title="12.Javascript作用链域?"></a>12.Javascript作用链域?</h4><pre><code>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。
当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，
直至全局函数，这种组织形式就是作用域链。
</code></pre><h4 id="13-谈谈This对象的理解"><a href="#13-谈谈This对象的理解" class="headerlink" title="13.谈谈This对象的理解"></a><strong>13.谈谈This对象的理解</strong></h4><pre><code>**this总是指向函数的直接调用者（而非间接调用者）；**
如果有new关键字，this指向new出来的那个对象；
在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window。
</code></pre><h4 id="14-eval是做什么的？"><a href="#14-eval是做什么的？" class="headerlink" title="14.eval是做什么的？"></a>14.eval是做什么的？</h4><p>它的功能是把对应的字符串解析成JS代码并运行；<br>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。<br>由JSON字符串转换为JSON对象的时候可以用eval：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str=<span class="string">"&#123;name:'xiaohuan'&#125;"</span>;</div><div class="line"><span class="keyword">var</span> obj =<span class="built_in">eval</span>(<span class="string">'('</span>+ str +<span class="string">')'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(obj));</div></pre></td></tr></table></figure></p>
<h4 id="15-什么是window对象-什么是document对象"><a href="#15-什么是window对象-什么是document对象" class="headerlink" title="15.什么是window对象? 什么是document对象?"></a>15.什么是window对象? 什么是document对象?</h4><pre><code>window对象是指浏览器打开的窗口。
document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。
</code></pre><h4 id="16-null，undefined-的区别？"><a href="#16-null，undefined-的区别？" class="headerlink" title="16.null，undefined 的区别？"></a>16.null，undefined 的区别？</h4><pre><code>null        表示一个对象是“没有值”的值，也就是值为“空”；
undefined   表示一个变量声明了没有初始化(赋值)；

undefined不是一个有效的JSON，而null是；
undefined的类型(typeof)是undefined；
null的类型(typeof)是object；


Javascript将未赋值的变量默认值设为undefined；
Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。

typeof undefined
    //&quot;undefined&quot;
    undefined :是一个表示&quot;无&quot;的原始值或者说表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined；
    例如变量被声明了，但没有赋值时，就等于undefined

typeof null
    //&quot;object&quot;
    null : 是一个对象(空对象, 没有任何属性和方法)；
    例如作为函数的参数，表示该函数的参数不是对象；

注意：
    在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined
    null == undefined // true
    null === undefined // false

再来一个例子：

null
Q：有张三这个人么？
A：有！
Q：张三有房子么？
A：没有！

undefined
Q：有张三这个人么？
A：有！
Q: 张三有多少岁？
A: 不知道（没有被告诉）
</code></pre><h4 id="17-写一个通用的事件侦听器函数？"><a href="#17-写一个通用的事件侦听器函数？" class="headerlink" title="17.写一个通用的事件侦听器函数？"></a>17.<strong>写一个通用的事件侦听器函数？</strong></h4><pre><code>// event(事件)工具集，来源：github.com/markyun
markyun.Event = {
// 页面加载完成后
readyEvent : function(fn) {
    if (fn==null) {
        fn=document;
    }
    var oldonload = window.onload;
    if (typeof window.onload != &apos;function&apos;) {
        window.onload = fn;
    } else {
        window.onload = function() {
            oldonload();
            fn();
        };
    }
},
// 视能力分别使用dom0||dom2||IE方式 来绑定事件
// 参数： 操作的元素,事件名称 ,事件处理程序
addEvent : function(element, type, handler) {
    if (element.addEventListener) {
        //事件类型、需要执行的函数、是否捕捉
        element.addEventListener(type, handler, false);
    } else if (element.attachEvent) {
        element.attachEvent(&apos;on&apos; + type, handler);
    } else {
        element[&apos;on&apos; + type] = handler;
    }
},
// 移除事件
removeEvent : function(element, type, handler) {
    if (element.removeEventListener) {
        element.removeEventListener(type, handler, false);
    } else if (element.datachEvent) {
        element.detachEvent(&apos;on&apos; + type, handler);
    } else {
        element[&apos;on&apos; + type] = null;
    }
},
// 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
stopPropagation : function(ev) {
    if (ev.stopPropagation) {
        ev.stopPropagation();
    } else {
        ev.cancelBubble = true;
    }
},
// 取消事件的默认行为
preventDefault : function(event) {
    if (event.preventDefault) {
        event.preventDefault();
    } else {
        event.returnValue = false;
    }
},
// 获取事件目标
getTarget : function(event) {
    return event.target || event.srcElement;
},
// 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
getEvent : function(event) {
    return event?event:window.event;
}
};
</code></pre><h4 id="18-“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#18-“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="18.[“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>18.[“1”, “2”, “3”].map(parseInt) 答案是多少？</h4><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="literal">NaN</span>,<span class="literal">NaN</span>];</div></pre></td></tr></table></figure>
</code></pre><p>因为：[“1”, “2”, “3”].map(parseInt)等价于:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">str,index,array</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(str,index);</div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<p>当index==0时，parseInt按基数10解析，所以’1’解析为1;<br>当index==1时,基数小于2或大于36，parseInt解析为NaN;<br>当index==2时，parsInt按2进制解析,但3不属于2进制范畴，所以NaN</p>
<p>要想得到正确的值：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(str);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="19-事件是什么？IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#19-事件是什么？IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="19.事件是什么？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>19.事件是什么？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h4><ol>
<li>我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。</li>
<li>事件处理机制：IE是事件冒泡、Firefox同时支持 捕获型事件和冒泡型事件 两种事件模型；</li>
<li>ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）</li>
</ol>
<h4 id="20-什么是闭包（closure），为什么要用它？"><a href="#20-什么是闭包（closure），为什么要用它？" class="headerlink" title="20.什么是闭包（closure），为什么要用它？"></a>20.什么是闭包（closure），为什么要用它？</h4><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。</p>
<p>闭包的特性：<br>1.函数内再嵌套函数;<br>2.内部函数可以引用外层的参数和变量;<br>3.参数和变量不会被垃圾回收机制回收.</p>
<pre><code>//li节点的onclick事件都能正确的弹出当前被点击的li索引
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;ul id="testUL"&gt;</div><div class="line">    &lt;li&gt; index = 0&lt;/li&gt;</div><div class="line">    &lt;li&gt; index = 1&lt;/li&gt;</div><div class="line">    &lt;li&gt; index = 2&lt;/li&gt;</div><div class="line">    &lt;li&gt; index = 3&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    var nodes = document.getElementsByTagName("li");</div><div class="line">    for(i = 0;i&lt;nodes.length;i+= 1)&#123;</div><div class="line">        nodes[i].onclick = (function(i)&#123;</div><div class="line">                  return function() &#123;</div><div class="line">                     console.log(i);</div><div class="line">                  &#125; //不用闭包的话，值每次都是4</div><div class="line">                &#125;)(i);</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</code></pre><p>执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在<br>使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源<br>因为say667()的内部函数的执行需要依赖say667()中的变量<br>这是对闭包作用的非常直白的描述<br>      <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">say667</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Local variable that ends up within closure</span></div><div class="line">    <span class="keyword">var</span> num = <span class="number">666</span>;</div><div class="line">    <span class="keyword">var</span> sayAlert = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(num);</div><div class="line">    &#125;</div><div class="line">    num++;</div><div class="line">    <span class="keyword">return</span> sayAlert;</div><div class="line">&#125;</div><div class="line"> <span class="keyword">var</span> sayAlert = say667();</div><div class="line"> sayAlert()<span class="comment">//执行结果应该弹出的667</span></div></pre></td></tr></table></figure></p>
<h4 id="21-javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？"><a href="#21-javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="21.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？"></a>21.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</h4><p>use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行。</p>
<p>使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。<br>默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;<br>全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；<br>消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;</p>
<p>提高编译器效率，增加运行速度；<br>为未来新版本的Javascript标准化做铺垫</p>
<p>与正常模式相比，严格模式对Javascript的语法和行为，都做了一些改变：<br>1.在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line">v = <span class="number">1</span>; <span class="comment">// 报错，v未声明</span></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123; <span class="comment">// 报错，i未声明</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.静态绑定：Javascript语言的一个特点，就是允许”动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。<br>具体来说，涉及以下几个方面。<br>（1）禁止使用with语句<br>因为with语句无法在编译时就确定，属性到底归属哪个对象。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</div><div class="line"><span class="keyword">with</span> (o)&#123; <span class="comment">// 语法错误</span></div><div class="line">  v = <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（2）创设eval作用域<br>正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。<br>正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.info(<span class="built_in">eval</span>(<span class="string">"var x = 5; x"</span>)); <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.info(x); <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>3.增强的安全措施<br>（1）禁止this关键字指向全局对象<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> !<span class="keyword">this</span>;</div><div class="line">&#125; <span class="comment">// 返回false，因为"this"指向全局对象，"!this"就是false</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">return</span> !<span class="keyword">this</span>;</div><div class="line">&#125; <span class="comment">// 返回true，因为严格模式下，this的值为undefined，所以"!this"为true。</span></div><div class="line"></div><div class="line"><span class="comment">//因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">this</span>.a = <span class="number">1</span>;</div><div class="line">&#125;;</div><div class="line">f();<span class="comment">// 报错，this未定义</span></div></pre></td></tr></table></figure></p>
<p>（2）禁止在函数内部遍历调用栈<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line">f1.caller; <span class="comment">// 报错</span></div><div class="line">f1.arguments; <span class="comment">// 报错</span></div><div class="line">&#125;</div><div class="line">f1();</div></pre></td></tr></table></figure></p>
<p>4.禁止删除变量<br>严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> x;</div><div class="line"><span class="keyword">delete</span> x; <span class="comment">// 语法错误</span></div><div class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123;<span class="string">'x'</span>: &#123;</div><div class="line"><span class="attr">value</span>: <span class="number">1</span>,</div><div class="line"><span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">&#125;&#125;);</div><div class="line"><span class="keyword">delete</span> o.x; <span class="comment">// 删除成功</span></div></pre></td></tr></table></figure></p>
<p>5.显式报错<br>正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"v"</span>, &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;);</div><div class="line">o.v = <span class="number">2</span>; <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">get v() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</div><div class="line">&#125;;</div><div class="line">o.v = <span class="number">2</span>; <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>严格模式下，对禁止扩展的对象添加新属性，会报错。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.preventExtensions(o);</div><div class="line">o.v = <span class="number">1</span>; <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>严格模式下，删除一个不可删除的属性，会报错。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype; <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>6.重名错误<br>（1）对象不能有重名的属性<br>（2）函数不能有重名的参数<br>正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。</p>
<p>7.禁止八进制表示法<br>正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。</p>
<p>8.arguments对象的限制<br>（1）不允许对arguments赋值<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="built_in">arguments</span>++; <span class="comment">// 语法错误</span></div><div class="line"><span class="keyword">var</span> obj = &#123; set p(<span class="built_in">arguments</span>) &#123; &#125; &#125;; <span class="comment">// 语法错误</span></div><div class="line"><span class="keyword">try</span> &#123; &#125; <span class="keyword">catch</span> (<span class="built_in">arguments</span>) &#123; &#125; <span class="comment">// 语法错误</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">arguments</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 语法错误</span></div><div class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"arguments"</span>, <span class="string">"'use strict'; return 17;"</span>); <span class="comment">// 语法错误</span></div></pre></td></tr></table></figure></p>
<p>（2）arguments不再追踪参数的变化<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">a = <span class="number">2</span>;</div><div class="line"><span class="keyword">return</span> [a, <span class="built_in">arguments</span>[<span class="number">0</span>]];</div><div class="line">&#125;</div><div class="line">f(<span class="number">1</span>); <span class="comment">// 正常模式为[2,2]</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line">a = <span class="number">2</span>;</div><div class="line"><span class="keyword">return</span> [a, <span class="built_in">arguments</span>[<span class="number">0</span>]];</div><div class="line">&#125;</div><div class="line">f(<span class="number">1</span>); <span class="comment">// 严格模式为[2,1]</span></div></pre></td></tr></table></figure></p>
<p>（3）禁止使用arguments.callee<br>这意味着，你无法在匿名函数内部调用自身了。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">arguments</span>.callee; &#125;;</div><div class="line">f(); <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>9.函数必须声明在顶层<br>将来Javascript的新版本会引入”块级作用域”。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 语法错误</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 语法错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>10.保留字<br>为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。使用这些词作为变量名将会报错。<br>此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。</p>
<h4 id="22-如何判断一个对象是否属于某个类？"><a href="#22-如何判断一个对象是否属于某个类？" class="headerlink" title="22.如何判断一个对象是否属于某个类？"></a>22.如何判断一个对象是否属于某个类？</h4><p>javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。<br>(1) 使用typeof<br>typeof是一个一元运算符，返回结果是一个说明运算数类型的字符串。如：”number”，”string”，”boolean”，”object”，”function”，”undefined”（可用于判断变量是否存在）。 但 typeof 的能力有限，其对于Date、RegExp、Array类型返回的都是”object”。所以它只在区别对象和原始类型的时候才有用。要区一种对象类型和另一种对象类型，必须使用其他的方法。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>();<span class="comment">//"object"</span></div></pre></td></tr></table></figure></p>
<p>(2) 使用instanceof<br>instanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。instanceof方法可以判断变量是否是数组类型，但是只限同一全局环境之内，在一个页面有多个iframe的情况下，instanceof失效。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>;<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>(3) constructor<br>JavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">arr.constructor();<span class="comment">//[]</span></div></pre></td></tr></table></figure></p>
<p>(4) Object.prototype.toString.call()：该方法是目前为止发现的判断一个对象类型的最好的办法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(arr);<span class="comment">//[Object Date]</span></div></pre></td></tr></table></figure></p>
<p>(5)扩展一下，用于检测各种对象类型：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> is =&#123;</div><div class="line"><span class="attr">types</span> : [<span class="string">"Array"</span>, <span class="string">"Boolean"</span>, <span class="string">"Date"</span>, <span class="string">"Number"</span>, <span class="string">"Object"</span>, <span class="string">"RegExp"</span>, <span class="string">"String"</span>, <span class="string">"Window"</span>, <span class="string">"HTMLDocument"</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, c; c = is.types[i ++ ]; )&#123;</div><div class="line">is[c] = (<span class="function"><span class="keyword">function</span>(<span class="params">type</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) == <span class="string">"[object "</span> + type + <span class="string">"]"</span>;</div><div class="line">&#125;;</div><div class="line">&#125;)(c);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(is.Array([])); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(is.Date(<span class="keyword">new</span> <span class="built_in">Date</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(is.RegExp(<span class="regexp">/reg/ig</span>)); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h4 id="23-new操作符具体干了什么呢"><a href="#23-new操作符具体干了什么呢" class="headerlink" title="23.new操作符具体干了什么呢?"></a>23.new操作符具体干了什么呢?</h4><p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。<br>2、属性和方法被加入到 this 引用的对象中。<br>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.name=<span class="string">'xiaohuan'</span>;&#125;;</div><div class="line">Base.prototype.age = <span class="number">20</span>;</div><div class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Base();</div><div class="line"><span class="comment">//等价于</span></div><div class="line"><span class="keyword">var</span> obj  = &#123;&#125;;</div><div class="line">obj.__proto__ = Base.prototype;</div><div class="line">Base.call(obj);</div></pre></td></tr></table></figure></p>
<h4 id="24-用原生JavaScript的实现过什么功能吗？"><a href="#24-用原生JavaScript的实现过什么功能吗？" class="headerlink" title="24.用原生JavaScript的实现过什么功能吗？"></a><strong>24.用原生JavaScript的实现过什么功能吗？</strong></h4><h4 id="25-Javascript中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？"><a href="#25-Javascript中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="25.Javascript中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？"></a>25.Javascript中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？</h4><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hasOwnProperty</div></pre></td></tr></table></figure>
</code></pre><p>javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。</p>
<p>使用方法：</p>
<pre><code>object.hasOwnProperty(proName)
其中参数object是必选项。一个对象的实例。
proName是必选项。一个属性名称的字符串值。
</code></pre><p>如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false.</p>
<h4 id="26-对JSON-的了解？"><a href="#26-对JSON-的了解？" class="headerlink" title="26.对JSON 的了解？"></a>26.对JSON 的了解？</h4><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。<br>JSON 语法是 JavaScript 对象表示语法的子集,具体为：<br>数据在键值对中；数据由逗号分隔；<br>花括号保存对象；方括号保存数组<br>JSON 数据的书写格式是：名称/值对。名称/值对组合中的名称写在前面（在双引号中），值对写在后面(同样在双引号中)，中间用冒号隔开。<br>JSON 值可以是：数字（整数或浮点数）；字符串（在双引号中）；逻辑值（true 或 false）；数组（在方括号中）；对象（在花括号中）；null<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">"name"</span>:<span class="string">"John"</span>,<span class="string">"age"</span>:<span class="number">25</span>&#125;</div></pre></td></tr></table></figure></p>
<p>JSON字符串转换为JSON对象:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj =<span class="built_in">eval</span>(<span class="string">'('</span>+ str +<span class="string">')'</span>);</div><div class="line"><span class="keyword">var</span> obj = str.parseJSON();<span class="comment">//需引入jQuery 1.4.1 及以上版本</span></div><div class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(str);</div></pre></td></tr></table></figure></p>
<p>JSON对象转换为JSON字符串：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> last=obj.toJSONString();<span class="regexp">/必须引入https:/</span><span class="regexp">/github.com/</span>douglascrockford/<span class="built_in">JSON</span>-js/blob/master/json.js</div><div class="line"><span class="keyword">var</span> last=<span class="built_in">JSON</span>.stringify(obj);</div></pre></td></tr></table></figure></p>
<h4 id="27-forEach-call-““-function-a-a-style-outline-”1px-solid-”-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？"><a href="#27-forEach-call-““-function-a-a-style-outline-”1px-solid-”-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？" class="headerlink" title="27.[].forEach.call($$(““),function(a){a.style.outline=”1px solid #”+(~~(Math.random()(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？"></a>27.[].forEach.call($$(“<em>“),function(a){a.style.outline=”1px solid #”+(~~(Math.random()</em>(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？</h4><pre><code>获得了页面内所有的元素,为每个元素加上一个彩色边框。其中：
$$(&apos;*&apos;) 表示选择所以元素（将*换成别的即可选择特定元素，如 a,img...），~~表示取整（parsInt()）,toString(16)表示转换成16进制，.call(this，arguments)将操作象从[]改变成$$(&apos;*&apos;)。
参考：https://gold.xitu.io/entry/57d36f598ac2470062f63467
</code></pre><h4 id="28-js延迟加载的方式有哪些？"><a href="#28-js延迟加载的方式有哪些？" class="headerlink" title="28.js延迟加载的方式有哪些？"></a>28.js延迟加载的方式有哪些？</h4><p><strong>参考</strong>：<a href="http://blog.csdn.net/newborn2012/article/details/17057759" target="_blank" rel="external">http://blog.csdn.net/newborn2012/article/details/17057759</a><br>1.直接将script节点放置在之前，这样js脚本就会在页面显示出来之后再加载。<br>2.使用script标签的defer和async属性，defer属性为延迟加载，是在页面渲染完成之后再进行加载的，而async属性则是和文档并行加载，这两种解决方案都不完美，原因在于不是所有浏览器都支持。<br>3.通过监听onload事件，动态添加script节点(最常用)：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">downloadJSAtOnload</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">      element.src = <span class="string">"test2.js"</span>;</div><div class="line">      <span class="built_in">document</span>.body.appendChild(element);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener)</div><div class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>,downloadJSAtOnload, <span class="literal">false</span>);</div><div class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent)</div><div class="line">      <span class="built_in">window</span>.attachEvent(<span class="string">"onload"</span>,downloadJSAtOnload);</div><div class="line">   <span class="keyword">else</span> <span class="built_in">window</span>.onload =downloadJSAtOnload;</div><div class="line"> &lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>4.通过ajax下载js脚本，动态添加script节点。<br>这种方式与第二种类似，区别就在与js脚本的自动下载还是通过ajax下载，ajax的方式显然可控制性更好一点，它可以先下载js文件，但不立即执行：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();  </div><div class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"script1.js"</span>, <span class="literal">true</span>);  </div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </div><div class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;  </div><div class="line">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>)&#123;  </div><div class="line">            <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement (<span class="string">"script"</span>);  </div><div class="line">            script.type = <span class="string">"text/javascript"</span>;  </div><div class="line">            script.text = xhr.responseText;  </div><div class="line">            <span class="built_in">document</span>.body.appendChild(script);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;;  </div><div class="line">xhr.send(<span class="literal">null</span>);</div></pre></td></tr></table></figure></p>
<h4 id="29-Ajax-是什么-如何创建一个Ajax？"><a href="#29-Ajax-是什么-如何创建一个Ajax？" class="headerlink" title="29.Ajax 是什么? 如何创建一个Ajax？"></a>29.Ajax 是什么? 如何创建一个Ajax？</h4><p>ajax的全称：Asynchronous Javascript And XML,即 异步传输+js+xml。<br>所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验</p>
<p>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象<br>(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息<br>(3)设置响应HTTP请求状态变化的函数<br>(4)发送HTTP请求<br>(5)获取异步调用返回的数据<br>(6)使用JavaScript和DOM实现局部刷新</p>
<h4 id="30-Ajax-解决浏览器缓存问题？"><a href="#30-Ajax-解决浏览器缓存问题？" class="headerlink" title="30.Ajax 解决浏览器缓存问题？"></a>30.Ajax 解决浏览器缓存问题？</h4><p>1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。<br>2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。<br>3、在URL后面加上一个随机数： “fresh=” + Math.random();。<br>4、在URL后面加上时间搓：”nowtime=” + new Date().getTime();。<br>5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。</p>

          </section>
          <section>
            <ul style="list-style-type:none">
            
              <li class="page-prev"><a href=/2017/01/10/JavaScript基础知识之面试篇（二）/>上一篇：JavaScript基础之面试篇(二)</a></li>
        
        
          <li class="page-next"><a href=/2016/10/06/Hexo主题制作笔记（3）左侧边栏/>下一篇：左侧边栏滑进滑出问题</a></li>
        
            </ul>
          </section>
          
              <section id="comments">
              
                      <!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="post-JavaScript基础知识之面试篇" data-title="JavaScript基础之面试篇（一）" data-url="http://xhuanhuan.github.io/2017/01/10/JavaScript基础知识之面试篇/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    var duoshuoQuery = {short_name:'xhuanhuan'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
  </script>
<!-- 多说公共JS代码 end -->

                  
              </section>
          
          <!-- </article> -->
        </div>
        </div>
          </div>
          <div id="li-of-post" class = 'col-xs-12 col-xs-offset-0 col-md-3 col-md-offset-0 col-sm-4 col-sm-offset-0 col-lg-3 col-lg-offset-0'>
          <div class="well here">
            <div style = 'text-align:left'>
              <button type="button" class="btn btn-primary" id='but2'>内容列表</button>
              <hr>
            </div>
            <div class="postblock">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#摘要"><span class="toc-number">1.</span> <span class="toc-text">摘要</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JS基本数据类型"><span class="toc-number">1.1.</span> <span class="toc-text">1.JS基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-JS有哪些内置对象"><span class="toc-number">1.2.</span> <span class="toc-text">2.JS有哪些内置对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-列出几条JavaScript的基本规范？"><span class="toc-number">1.3.</span> <span class="toc-text">3.列出几条JavaScript的基本规范？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-JavaScript原型，原型链-有什么特点？"><span class="toc-number">1.4.</span> <span class="toc-text">4.JavaScript原型，原型链 ? 有什么特点？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1原型"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1原型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2原型链"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2原型链</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3特点"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-JavaScript有几种类型的值？你能画一下他们的内存图吗？"><span class="toc-number">1.5.</span> <span class="toc-text">5.JavaScript有几种类型的值？你能画一下他们的内存图吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-如何将字符串转化为数字，例如’12-3b’"><span class="toc-number">1.6.</span> <span class="toc-text">6.如何将字符串转化为数字，例如’12.3b’?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-如何将浮点数点左边的数每三位添加一个逗号，如12000000-11转化为『12-000-000-11』"><span class="toc-number">1.7.</span> <span class="toc-text">7.如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-如何实现数组的随机排序？"><span class="toc-number">1.8.</span> <span class="toc-text">8.如何实现数组的随机排序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-Javascript如何实现继承？"><span class="toc-number">1.9.</span> <span class="toc-text">9.Javascript如何实现继承？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-JavaScript继承的几种实现方式？"><span class="toc-number">1.10.</span> <span class="toc-text">10.JavaScript继承的几种实现方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-javascript创建对象的几种方式？"><span class="toc-number">1.11.</span> <span class="toc-text">11.javascript创建对象的几种方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-Javascript作用链域"><span class="toc-number">1.12.</span> <span class="toc-text">12.Javascript作用链域?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-谈谈This对象的理解"><span class="toc-number">1.13.</span> <span class="toc-text">13.谈谈This对象的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-eval是做什么的？"><span class="toc-number">1.14.</span> <span class="toc-text">14.eval是做什么的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-什么是window对象-什么是document对象"><span class="toc-number">1.15.</span> <span class="toc-text">15.什么是window对象? 什么是document对象?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-null，undefined-的区别？"><span class="toc-number">1.16.</span> <span class="toc-text">16.null，undefined 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-写一个通用的事件侦听器函数？"><span class="toc-number">1.17.</span> <span class="toc-text">17.写一个通用的事件侦听器函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-“1”-“2”-“3”-map-parseInt-答案是多少？"><span class="toc-number">1.18.</span> <span class="toc-text">18.[“1”, “2”, “3”].map(parseInt) 答案是多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-事件是什么？IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><span class="toc-number">1.19.</span> <span class="toc-text">19.事件是什么？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-什么是闭包（closure），为什么要用它？"><span class="toc-number">1.20.</span> <span class="toc-text">20.什么是闭包（closure），为什么要用它？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？"><span class="toc-number">1.21.</span> <span class="toc-text">21.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-如何判断一个对象是否属于某个类？"><span class="toc-number">1.22.</span> <span class="toc-text">22.如何判断一个对象是否属于某个类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-new操作符具体干了什么呢"><span class="toc-number">1.23.</span> <span class="toc-text">23.new操作符具体干了什么呢?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-用原生JavaScript的实现过什么功能吗？"><span class="toc-number">1.24.</span> <span class="toc-text">24.用原生JavaScript的实现过什么功能吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-Javascript中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？"><span class="toc-number">1.25.</span> <span class="toc-text">25.Javascript中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-对JSON-的了解？"><span class="toc-number">1.26.</span> <span class="toc-text">26.对JSON 的了解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-forEach-call-““-function-a-a-style-outline-”1px-solid-”-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？"><span class="toc-number">1.27.</span> <span class="toc-text">27.[].forEach.call($$(““),function(a){a.style.outline=”1px solid #”+(~~(Math.random()(1<<24))).toString(16)}) 能解释一下这段代码的意思吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-js延迟加载的方式有哪些？"><span class="toc-number">1.28.</span> <span class="toc-text">28.js延迟加载的方式有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29-Ajax-是什么-如何创建一个Ajax？"><span class="toc-number">1.29.</span> <span class="toc-text">29.Ajax 是什么? 如何创建一个Ajax？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-Ajax-解决浏览器缓存问题？"><span class="toc-number">1.30.</span> <span class="toc-text">30.Ajax 解决浏览器缓存问题？</span></a></li></ol></li></ol>
            </div>
          </div>
        </div>

      </div>
    </div>
    <div style="width:100%;position:fixed;bottom:5px">
    <button id="up" class="btn btn-default"><i class="icon-angle-up"></i></button>
    </div>
    <footer>
    <div class="info" style="text-align:center;"><span>Powered By <a href="https://hexo.io/" target="blank">Hexo</a></span>&nbsp;&nbsp;&nbsp;&nbsp;<span>Theme by <a href="https://github.com/xhuanhuan/xhuanhuan.github.io/" target="blank">Xhuanhuan</a></span></div>
</footer>

</article>


    </div>
      <script src="/js/jquery-1.12.3.min.js"></script>
      <script src="/js/index.js"></script>
      <script src="/js/bootstrap.min.js"></script>
      
</body>
</html>
